function [ProjIm,DepthMap] = createProjection(ImStack, SmoothingRadius, depthThreshold,SurfSmoothness1,SurfSmoothness2,ShowProcess)
% createProjection - [1 line description ]
%
% IN: 
%   ImStack - image stack generated by 'LoadImages' (?)
%   SmoothingRadius - 
%   depthThreshold - 
%   SurfSmoothness1 -
%   SurfSmoothness1 - 
%   ShowProcess - 
%
% OUT: 
%   ProjIm - projected ImStack without ...
%   DepthMap - surface used to project the data
%
% Author:
% Copyright:

fprintf('Creating smart projection ... ')
tic

s=size(ImStack); 

% doing some simple smoothing
gaussianProfile = fspecial( 'gaussian', [s(1) s(2)], SmoothingRadius);
I1 = zeros([s(1), s(2),s(3) ]);
for z=1:s(3),
    I1(:,:,z) = real(fftshift(ifft2(fft2(ImStack(:,:,z)).*fft2(gaussianProfile))));
end

% ---- prepare surface ---------                                           % what does prepare mean?
[vm1,depthmap] = max(I1,[],3);                                             % var names ?
confidencemap = s(3)*vm1./sum(I1,3);

c = confidencemap(:);
confthres = median(c(c > median(c)));

% keep only the brightest surface points (intensity in 1 quartile)
% assumed to be the surface of interest
depthmap2=depthmap.*double(confidencemap>confthres);                       % renaming depthmatp2 would help

%now fit a surface through these high-intensity points

[y,x]=find( depthmap2 > 0);
z=depthmap2(depthmap2 > 0);

xnodes = 1:s(2);
ynodes = 1:s(1);
tilesize = max(s(1),s(2));

%                                                                          % parameter break down, e.g. 
[zg1,xg1,yg1] = gridfit(...
    x,y,z,xnodes,ynodes,...
    'tilesize',tilesize,...
    'overlap',0.25,...
    'smoothness',SurfSmoothness1,...
    'interp','bilinear','regularizer','springs');

if ShowProcess
    figure
    surf(xg1,yg1,zg1) 
    zlim([0,max(zg1(:))]);
    shading interp
    colormap(jet(256))
    camlight right
    lighting phong
    title 'Tiled gridfit'
end


depthmap3=abs(zg1-depthmap2);                                              % whats happening here?

depthmap3(depthmap2==0)=0;

% only keep points which are relatively close to our first estimate
depthmap4 = depthmap2.*(depthmap3 < depthThreshold); 

% --- 2nd iteration -                                                      % why a second iteration? 

[y,x]=find( depthmap4 > 0);
z=depthmap4(depthmap4 > 0);


xnodes = 1:s(2);
ynodes = 1:s(1);
[zg2,xg2,yg2] = gridfit(...
    x,y,z,xnodes,ynodes,...
    'tilesize',tilesize,...
    'overlap',0.25,...
    'smoothness',SurfSmoothness2,...
    'interp','bilinear','regularizer','springs');

if ShowProcess
    figure
    surf(xg2,yg2,zg2)
    zlim([0,max(zg2(:))]);
    shading interp
    colormap(jet(256))
    camlight right
    lighting phong
    title 'Tiled gridfit'
end

% ----- creating projected image from interpolated surface estimation ------

projected_image=zeros(s(1),s(2),'like',ImStack);
z_origin_map = zeros(s(1),s(2),'uint8'); % supports up to 256 planes


for y=1:s(1),
    for x=1:s(2),
        if (zg2(y,x) > 0)
            z_coordinate = round(zg2(y,x));
            z_origin_map(y,x) = z_coordinate;
            projected_image(y,x)=ImStack(y,x,z_coordinate);
        end
    end
end

fprintf('Finished. ')
toc

ProjIm = projected_image;
DepthMap = z_origin_map;



