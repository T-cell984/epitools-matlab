function [ProjIm,DepthMap] = CreateProjectionMarkers(ImStack, markers)
%, SmoothingRadius, depthThreshold,SurfSmoothness1,SurfSmoothness2,ShowProcess)
% createProjection - [1 line description ]
%
% IN: 
%   ImStack - image stack generated by 'LoadImages' (?)
%   SmoothingRadius - 
%   depthThreshold - 
%   SurfSmoothness1 -
%   SurfSmoothness1 - 
%   ShowProcess - 
%
% OUT: 
%   ProjIm - projected ImStack without ...
%   DepthMap - surface used to project the data
%
% Author:
% Copyright:



%Imstack=(imread3('1A_fast.tif'));

% markers=imread3('markers_a1.tif');
% markermap=double(markers(:,:,frame));
% 
% 
% ImStack=double(Imstack(:,:,((frame-1)*zslices)+1:frame*zslices));


SmoothingRadius=5;
SurfSmoothness1=30;
SurfSmoothness2=20;
ShowProcess=0;
depthThreshold=1.5;


s=size(ImStack); 

tic;


if (sum(markers(:)) > 0)
    
  [y,x]=find( markers > 0);
  z=markers(markers > 0);

  tilesize = max(s(1),s(2));
  
  
  xnodes = 1:s(2);
  ynodes = 1:s(1);
  [zg2,xg2,yg2] = gridfit(...
    x,y,z,xnodes,ynodes,...
    'tilesize',tilesize,...
    'overlap',0.25,...
    'smoothness',SurfSmoothness2,...
    'interp','bilinear','regularizer','springs');

if ShowProcess
    figure('Name','2nd Surface Estimation');
    surf(xg2,yg2,zg2)
    zlim([0,max(zg2(:))]);
    shading interp
    colormap(jet(256))
    camlight right
    lighting phong
    title 'Tiled gridfit'
end
  
% ----- creating projected image from interpolated surface estimation ------

projected_image=zeros(s(1),s(2),class(ImStack));
z_origin_map = zeros(s(1),s(2),'uint8'); % supports up to 256 planes


  for y=1:s(1),
    for x=1:s(2),
        if (zg2(y,x) > 0)
            z_coordinate = round(zg2(y,x));
            int1=ImStack(y,x,z_coordinate);
            z_origin_map(y,x) = z_coordinate;
            if (z_coordinate < s(3))
                int2=ImStack(y,x,z_coordinate+1);
                if (int2 > int1) 
                    int1=int2;
                    z_origin_map(y,x) = z_coordinate+1;
                end
            end
            if (z_coordinate > 1)
                int2=ImStack(y,x,z_coordinate-1);
                if (int2 > int1) 
                    int1=int2;
                    z_origin_map(y,x) = z_coordinate-1;
                end
            end
            
            projected_image(y,x)=int1;
        end
    end
 end
  
  
  
else

    
% doing some simple smoothing
gaussianProfile = fspecial( 'gaussian', [s(1) s(2)], SmoothingRadius);
I1 = zeros([s(1), s(2),s(3) ]);
for z=1:s(3),
    I1(:,:,z) = real(fftshift(ifft2(fft2(ImStack(:,:,z)).*fft2(gaussianProfile))));
end
    
    
% ---- prepare surface ---------                                           % what does prepare mean?
[vm1,depthmap] = max(I1,[],3);                                             % var names ?
confidencemap = s(3)*vm1./sum(I1,3);

c = confidencemap(:);
confthres = median(c(c > median(c)));

% keep only the brightest surface points (intensity in 1 quartile)
% assumed to be the surface of interest
depthmap2=depthmap.*double(confidencemap>confthres);                       % renaming depthmatp2 would help

%now fit a surface through these high-intensity points

% if we have markers then use those
  [y,x]=find( depthmap2 > 0);
  z=depthmap2(depthmap2 > 0);
  

xnodes = 1:s(2);
ynodes = 1:s(1);
tilesize = max(s(1),s(2));

% for more information on gridfit see the program header
[zg1,xg1,yg1] = gridfit(...
    x,y,z,xnodes,ynodes,...
    'tilesize',tilesize,...
    'overlap',0.25,...
    'smoothness',SurfSmoothness1,...
    'interp','bilinear','regularizer','springs');

if ShowProcess
    figure('Name','1st Surface Estimation');
    surf(xg1,yg1,zg1) 
    zlim([0,max(zg1(:))]);
    shading interp
    colormap(jet(256))
    camlight right
    lighting phong
    title 'Tiled gridfit'
end


% given the hight locations of the surface (zg1) compute the difference
% towards the 1st quartile location (depthmap2), ignore the rest (==0);
% the result reflects the distance (abs) between estimate and points.
depthmap3=abs(zg1-depthmap2);                                              
depthmap3(depthmap2==0)=0;

% only keep points which are relatively close to our first estimate,
% i.e. below the threshold. TIP: if the first estimate is too detailed(~=smooth)
% the points from the peripodial membrane will not be eliminated since
% the surface approximated them well. Increase the smoothness to prevent this.
depthmap4 = depthmap2.*(depthmap3 < depthThreshold); 

%TIP: depthmap4 should only contain signal of interest at this point.

% --- 2nd iteration - 
% compute a better more detailed estimate with the filtered list (depthmap4)
% this is to make sure that the highest intensity points will be
% selected from the correct surface (The coarse grained estimate could
% potentially approximate the origin of the point to another plane)

[y,x]=find( depthmap4 > 0);
z=depthmap4(depthmap4 > 0);

xnodes = 1:s(2);
ynodes = 1:s(1);
[zg2,xg2,yg2] = gridfit(...
    x,y,z,xnodes,ynodes,...
    'tilesize',tilesize,...
    'overlap',0.25,...
    'smoothness',SurfSmoothness2,...
    'interp','bilinear','regularizer','springs');

if ShowProcess
    figure('Name','2nd Surface Estimation');
    surf(xg2,yg2,zg2)
    zlim([0,max(zg2(:))]);
    shading interp
    colormap(jet(256))
    camlight right
    lighting phong
    title 'Tiled gridfit'
end

% ----- creating projected image from interpolated surface estimation ------

projected_image=zeros(s(1),s(2),class(ImStack));
z_origin_map = zeros(s(1),s(2),'uint8'); % supports up to 256 planes


for y=1:s(1),
    for x=1:s(2),
        if (zg2(y,x) > 0)
            z_coordinate = round(zg2(y,x));
            z_origin_map(y,x) = z_coordinate;
            projected_image(y,x)=ImStack(y,x,z_coordinate);
        end
    end
end

end

elapsedTime = toc;


gaussianProfile = fspecial( 'gaussian', [s(1) s(2)], 1);
ProjIm = real(fftshift(ifft2(fft2(projected_image).*fft2(gaussianProfile))));


DepthMap = z_origin_map;

end



